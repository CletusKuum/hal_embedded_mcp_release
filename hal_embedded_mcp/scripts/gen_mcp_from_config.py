#!/usr/bin/env python3
"""
HAL Embedded MCP - Config-to-C and Config-to-Python Generator
------------------------------------------------------------------------------
Single config (config.json) â†’ generates C for MCU and Python for MCP server.
Same pattern as gpio_driver/scripts/gen_config.py.

Usage:
  python gen_mcp_from_config.py <config.json> [options]
  --c-out <path>       Write C pin names table (e.g. mcu/build/mcp_pins_gen.c)
  --python-out <path>  Write Python schema (e.g. server/generated/mcp_schema.py)
  --help               Show this help
"""

import argparse
import json
import os
import sys


def generate_c_pins(json_data):
    """Generate C file: pin names array for MCU validation only.
    Actual pin control uses gpio_config_gen.c (g_psGpioPinConfigs) from the
    same config.json via gpio_driver/scripts/gen_config.py."""
    pins = json_data.get("pins", [])
    lines = [
        "// ============================================================================",
        "// AUTO-GENERATED - DO NOT EDIT MANUALLY",
        "// Generated by hal_embedded_mcp/scripts/gen_mcp_from_config.py",
        "//",
        "// MCP tool validation only (allowed pin names). Pin control uses",
        "// gpio_config_gen.c (g_psGpioPinConfigs) from the same config.json.",
        "// ============================================================================",
        "",
        "#include <stddef.h>",
        "",
        "const char *const g_apcMcpPinNames[] = {",
    ]
    for pin in pins:
        name = pin.get("name", "")
        lines.append(f'    "{name}",')
    lines.append("    NULL")
    lines.append("};")
    lines.append("")
    lines.append(f"const unsigned int g_u32McpPinCount = {len(pins)};")
    return "\n".join(lines)


def generate_python_schema(json_data):
    """Generate Python module: pin list and tool list for MCP server."""
    pins = json_data.get("pins", [])
    mcp = json_data.get("mcp", {})
    tools = mcp.get("tools", ["gpio_write", "gpio_read"])
    pin_names = [p.get("name", "") for p in pins if p.get("name")]

    lines = [
        "# AUTO-GENERATED - DO NOT EDIT MANUALLY",
        "# Generated by hal_embedded_mcp/scripts/gen_mcp_from_config.py",
        "",
        "MCP_PIN_NAMES = [",
    ]
    for name in pin_names:
        lines.append(f'    "{name}",')
    lines.append("]")
    lines.append("")
    lines.append("MCP_TOOLS = [")
    for t in tools:
        lines.append(f'    "{t}",')
    lines.append("]")
    lines.append("")
    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Generate C and Python from hal_embedded_mcp config.json"
    )
    parser.add_argument("config", help="Path to config.json")
    parser.add_argument(
        "--c-out",
        metavar="PATH",
        help="Output path for C file (mcp_pins_gen.c)",
    )
    parser.add_argument(
        "--python-out",
        metavar="PATH",
        help="Output path for Python schema (mcp_schema.py) or directory",
    )
    args = parser.parse_args()

    if not os.path.isfile(args.config):
        print(f"Error: config not found: {args.config}", file=sys.stderr)
        sys.exit(1)

    with open(args.config, "r", encoding="utf-8") as f:
        data = json.load(f)

    any_out = False

    if args.c_out:
        c_content = generate_c_pins(data)
        os.makedirs(os.path.dirname(os.path.abspath(args.c_out)) or ".", exist_ok=True)
        with open(args.c_out, "w", encoding="utf-8") as f:
            f.write(c_content)
        print(f"Generated {args.c_out}")
        any_out = True

    if args.python_out:
        py_content = generate_python_schema(data)
        out_path = args.python_out
        if os.path.isdir(out_path) or not os.path.splitext(out_path)[1]:
            out_path = os.path.join(out_path.rstrip("/\\"), "mcp_schema.py")
        os.makedirs(os.path.dirname(os.path.abspath(out_path)) or ".", exist_ok=True)
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(py_content)
        print(f"Generated {out_path}")
        any_out = True

    if not any_out:
        print("No outputs requested. Use --c-out and/or --python-out.", file=sys.stderr)
        sys.exit(1)

    return 0


if __name__ == "__main__":
    sys.exit(main())
